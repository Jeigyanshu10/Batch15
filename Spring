Spring:

1. Spring is a dependency injection framework to make java applications loosely coupled.
2. It was developed by Rod Johnson in 2003.
3. Dependecy Injection:
	1. It's a pattern using which we can build applications. Normally while developing an app using java, we tend to create a lot of classes. 
	2. Since the Java language is bases on OOPs we tend to use a lot of classes for our convinience and then use them across our application.


class Student{
	int id
	String name;
	Address address;
}	

class Address{

	String street;
	String city;
	String state;
	String country;

}
	In the above two classes, the class Student is using an instance of Address in order to function. As a developer so far 
		1. We were responsible for creating those objects
		2. And also creating in the right place 
	Result: this has to be a manual process which is why we had to do it before compiling the program. Result: The program becomes tightly coupled and we can't change anything during the runtime. 
	
	Hence it won't be a mistake to say, till this point of time we had the control in our hands. But as the application starts getting huge things starts to get a little out of hands which make creating objects and also using it in the right place a little challenging.
	
Hence with the control in our hands below are the issue we have noticed:
	1. Creation of objects has to be manual.
	2. Since there is a human intervention and in an entrprise applications we will have to deal with a lot of classes, it is quite possible, that we might use an unwanted object.
	3. my application will become tightly coupled because there is no flexibilty during the run time.
To overcome such issues we make use of the Spring Framework which is capable of creating the required object in the runtime and inject it to the position where it is required in the runtime. 	


Spring Framework:


Data-	      JDBC, ORM 						Web: Web,Servlet				
integration	  JMS, OXM								 Portlet,Websocket		


	  AOP , Aspect, Intrumentation , Messaging: Used to decouple our code.
Core: Core , Bean , Context ,spEl: provides Fundamental functionality like IOC,dependency injection. 
								Testing

The context extends Bean so it has all its feature and also some unique feature.



Ioc Container: is a component that comes with Spring framework which is responsible for 
	1. creation of object, 
	2. Holding them in the memory and 
	3. Injecting the objects inside another objects.

Hence the IOC container has a grip on the objects and maintains the entire life cycle of the objects created.

We need to provide two different things:
	1. Beans Information
	2. Configuration information (Which bean is dependent on what)


Application Context: It represent our IOC container. 
The Bean factory is something which is responsible for creating all the objects. However the application context extends the Bean Factory and hence has all its properties and also has some addition features.

This is an interface using which we can extract objects from inside the container.

Since this is an interface we can't directly create an object of this interface and there are 3 implementation class which helps us do that.
	1.ClassPathXMLApplicationContext
	2.AnnotationConfigApplicationContext
	3.FileSystemXMLApplicationContext	
Different types of Dependency injection:

class Student{
	int id
	String name;
	Address address;
}	

class Address{

	String street;
	String city;
	String state;
	String country;

}


IoC will create this object of Address and then initialize the values to the properties.
Also it will create the Student and initialie the values and then it also injects the Address object into the Student object during the runtime automatically.

Dependency Injection can be done in 2 ways:
1. Setter Injection: It uses the bean classes setter methods to inject the properties. The properties can be primitive or non primitive
2. Constructor Injection: It uses the constructor to set the properties of an object.


Configuration File: XML file
In order for the IOC container to create object and do all sort of initialization, we need to provide information regarding the class(Otherwise called as bean) of which we want the container to create object of.


Hence in a single line we can say configuration file is a place where we declare our beans and its dependency

Different type Data that can be injected into an object by the IOC container:
1. Primitive Datatype: byte, short,char,int,float,double,long
2. Collection type: List, Set,Map,Properties
3. Reference Type / Non primitive data type

Dive into practical:

Next Steps:
1. Create a Maven Project(So that we can easily add the spring dependencies)
2. Adding dependencies -> Spring Core, Spring context
3. Creating beans -> Java Pojo
4. Creating configuration file -> config.xml
5. Setter Injection
6. Main Class: Using which we will pull the data.


Software Required: 
1. Eclipse (IDE)
2. Tomcat Server (Web Server to run our project)
3. MySql Database
4. Workbench for mysql gui

pom.xml: It stands for project object model and this is the place where we add all the dependencies required by our projet.

1. Lets find out how to set values to the object properties using the Setter injection

Name space for config file:

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">  

</beans>    

Note: There are 3 ways of providing values to the beans. 
	1. Using the value tag(<value></value>)
	2. Value as attribute ()
	3. Using p schema

Note: When we provide property tag spring automatically assumes we want to use the setter injection

So far we have learnt how to inject primitive data type to the object. Lets learn how to inject collection objects to our objects

Syntax:(List & Set)


<bean>
	<property name="List/SetCollectionTest">
			<list/set>
				<value>10<value>
				<value>637<value>
				<value>11223<value>
				<value>14532<value>
				<null/>
			</list/set>
	</property>
</bean>
-------------------------------------------------------
Syntax(Map)

<bean>
	<property name="MapCollectionTest">
			<map>
				<entry key="IronMan" value="Tony Strak" />
				<entry key="Amazing Spider Man" value="Peter Parker" />
			</map>
	</property>
</bean>
-------------------------------------------------------
Syntax(Properties)

<bean>
	<property name="PropertyCollectionTest">
			<props>
				<prop key="IronMan">Tony Strak<prop>
				<prop key=Amazing Spider Man>Peter Parker<prop>
			</props>
	</property>
</bean>

Assignment: In our program try to implement the properties using the above syntax

--------------------------------------------------------------

Injecting Reference type of data into objects:

Reference Type:

Syntax:

<bean class =somepackage.B name="B">
</bean>


<bean class=somepacakage.A name="A">
	<property name="ReferenceTest">
		<ref bean="b" // here b is the name of the bean on which the current 				  		  // bean is dependent on
	</property>
</bean>

Just like the other primitive data-type we can also use the value as attribute in this case as well. Below is an example:
Eg:
<bean class="com.technoelevate.SpringCore.ReferenceTypeInjection.A" name="aref">
		<property name="x" value="20"/>
		<property name="obj" ref ="bref"/>
		//"bref" represent the name of the bean on which "aref" is dependent on.
	</bean>


Constructor Injection:
Syntax for Constructor injection: <constructor-arg></constructor-arg>
Syntax for setter injection: <property> </property>


Here is an example of a constructor injection:

Eg:
<bean class="com.technoelevate.SpringCore.ConstructorInjection.Person" name="person">
    	<constructor-arg value="Jeigyanshu" />
    	<constructor-arg value="20" />
    	<constructor-arg ref="certificate"/>
    	</bean>

// The "certificate" in the 3rd argument which represent a bean on which the "person" bean is dependent on

All the experience/technique we have used for the setter injection is almost the same in constructor injection.

Assignment1: Use C schema to provide the values to the class properties.
Assignment2: use a list type input in the Person Class to represent a collection and provide the appropriate tag in the xml file. 

Note: While getting the objects created using the constructor injection, the order in which we declare the class properties matters. However, if we provide the type then we can use it in the order as per our wish, but if there is a conflict between the same type then the IOC container is going to give preference in the sequence in which they appear in the constructor.

Ambiguity in the Constructor injection:

By default the values are passed as String into the constuructor and below is the order:

Default order: String -> then the sequence where it find the first matching value.
However if we want to fixate the type then we have to explicitly mention the type in the <constructor-arg>
Eg: <constructor-arg value="34" type="int"/>

Note: We can send the value to the parameter based on our choice, this can be done by using the index attribute in the <constructor-arg>


Eg:
<bean
		class=" com.technoelevate.SpringDemo.ConstructorInjection.Addition"
		name="add">
		<constructor-arg value="15" type="double" index="1"/>
		<constructor-arg value="20" type="double" index="0"/>
	</bean>




Life Cycle Methods of Spring Bean:
Spring provide two important methods to every bean:

1. public void init()//Used to initializing the code->loading config,connecting db,webservice etc.

2. public void destroy()//Used to provide CleanUp code.

Life cycle step:

As soon as we provide the spring bean info and the metadata(Configuration Xml file),
1. It creates the object
2. Sets the class properties using the setter/constructor injection.
3. Calls the init() to initialize all the resources we might have declared inside the bean
4. Then we read and use the bean
5. Just before destroying the object it will call the destroy() where we have the cleanup code
6. Destroy's the object.



Configurationn Technique:
1. Xml

Eg:
    <bean class="com.technoelevate.SpringCore.LifeCycle.Samosa" name="samosa1" 
    				init-method="init" destroy-method="destroy">
    	<property name="price" value="10"/>
    </bean>
2. Spring Interface : We implement the below two interface

InitializingBean(I)-> Initializing Bean
DisposableBean(I)-> Destroying Bean

3. Annotation:

1. @PostConstruct
2. @PreDestroy

We need to add the below dependency:

<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>
</dependency>


Autowiring in Spring:
1. Feature of spring framework in which spring container inject the dependencies automatically.
2.We cannot provide autowiring for primitive datatype and String value. It works only with reference only.

Explanation:

A----------------------------->B

If A requires the object of B, so far we were doing it manually by writing the below:
<bean class="qualified name" name="bname">
<ref bean="bname"/>

There is an another way of doing this where we tell the IOC container to do it by itself. This is nothing but called as autowiring.

Autowiring
1. Using XML: Therng again can be done in 2 ways:e are few modes using which we can get this done:
	1. No: It disables the autowiring
	2. byName: It injects the dependencies using name
	3. byType: It injects the dependencies using type
	4. constructor: It injects the dependencies using constructor
	5. autodetect: It automatically detects and injects the dependencies. However, this is depricated since Spring 3.

2. Using Annotations:
	@Autowired

Advantage:
1. Automatic
2. Less Code

Disadvantage:
1. No control of programmer
2. Can't be used for primitive and String values.

Autowiring using the XML:

byName:
<bean class="com.technoelevate.SpringCore.Autowire.Employee" autowire="byName"/>


1. It is worth noticing that the name of the supporter bean has to be exactly the same as of the variable name in the dependent class, only then it will lookup the variable else it will return null by default.

Note: While getting the bean if we don't want to type cast it, then the getBean() is a overloaded method which accepts the object.class which is automatically type cast the bean we will fetch.

byType:

<bean class="com.technoelevate.SpringCore.Autowire.Employee" autowire="byType"/>

1. It dosen't care about the name of the support bean and the reference variable name in the dependent object. All it tries to match is the type of the object.

2. While this is a cool approach of injecting the dependency, it is worth remembering that in case the class has multiple variable of the dependent object then we can't use the "byType" to get it autowired. If we do that we will run into errors. In such cases the best approach is to use the "byName"


Constructor:

<bean class="com.technoelevate.SpringCore.Autowire.Employee" name="emp2" autowire="constructor">

1. It automatically finds the bean which is eligible to be injected as a constructor and then inject it.
2. If the dependent class has more than 1 type of the same non-primitive type of data, in such cases:
	a. If there is a single bean, then it injects the single bean in both the parameter. The name of the bean here is not of any importance.
	b. If there are more than 1 bean of the dependent type in that case, the name of the bean has to match the name of the variable in the dependent class.

Autowiring using Annotation:

We can use the @Autowire in object declaration or setter methods or Constructors.

@Qualifier Annotation:
If we want to map a particular bean to be assigned to a specific variable in the dependent class then we go for the @Qulaifier("name of the bean") annotation.

Stereotype Annotaion:
So far we were using the xml file, to declare all the classes for which we wanted a bean. However, the same job can also be done using the @Component annotation directly over the dependent class.

Eg:

@Component
class Student{
	
} 

In order for the class to be created as a bean we also need to provide the package name inside the xml file using the below format.

<context:component-scan base-package="com.technoelevate.SpringCore.StereotypeAnnotation"/>

While declaring the class name in the xml file we use to provide the name of the bean, since we are not decalring any sort bean here hence there is no scope to provide the name in which the object/bean can be stored.
The IOC container by default looks up to the class name and use the camel case to store the object.
Eg:

@Component
class StudentFamily{
	
} 

The variable for the above scenario is student. Hence while getting the bean we would write something like below:

context.getBean("studentFamily",StudentFamily.class)

Having said that the situation at all demands to give a different name in such case we can do it by passing the required variable right after the component. Below is an example:

@Component("std")
class StudentFamily{
	
} 

In the above case we can access object/bean created the below format:
context.getBean("std",Student.class)




Bean Scope:
There are 5 scopes:
1. Singleton: This is by default
2. prototype
3. session
4. request
5. Globalsession


Creating A StandAlone Collection:
 If we want to use a initialized collection repetedly then we can create a standalone collection and use it in our code taking help of spring expression language.

Include the below schema:
xmlns:util="http://www.springframework.org/schema/util"

schemaLocation:
http://www.springframework.org/schema/util
    http://www.springframework.org/schema/util/spring-util.xsd

 Eg:
 <context:component-scan base-package="com.technoelevate.SpringCore.StereotypeAnnotation"/>
    <util:list list-class ="java.util.ArrayList" id="studentAddresses">
    	<value>7019344625</value>
    	<value>7019344626</value>
    	<value>7019344627</value>
    </util:list>


Annotation Based:
So far we have learnt how to create bean and provide the necessary injections with the help of xml. Now we will enter into completly XML less bean creation.

@Configuration: IOC understands that this is the class which handles the configuration of the project.

@ComponentScan(basePackages+"base package address"): This will tell the IOC container out of many pacakages and class which package are we intrested of creating the bean.

@Bean: For an instance we do not want different class to have the @Component but still we need to create a bean of the class, in such sceinario we need to create a method inside the configuration class which returns an object of the respective/required class and annotate it with @Bean.

So this is how it works:
1. We create a java class which we can consider as a configuration class and has all the information of the pacakages from which we need to create the beans.

2. The class of which we need a bean(doesn't matter in which pacakage) we need to annotate that class by using the @Component(as we have seen before).

3. We need to create an object of ApplicationContext but instead of ClassPathXmlApplicationContext we will use AnnotationConfigApplicationContext().

4. AnnotationConfigApplicationContext(), this method except an argument which is of a class type. We need to provide the class of the configuration we created in step 1.

5. Now my main method knows which class is the configuration class which contains all the information about the pacakge of which we might need to create the bean of.

6. Once this is done we need to get the bean:
	1. We have annotated all the class for which we might need the bean in step 2
	2. We already know that the IOC will use the Java standards name to hold the bean.
	3. Now we will use the context.getBean("name deduced from step6.2",Bean'sClass.class) 
	4. This will provide me the required bean.
7. Now that we have the bean/object we can use it as per our requirements.

Alternate way:

1. We create a java class which we can consider as a configuration class and has all the information of the pacakages from which we need to create the beans.

2. If we are not intrested in using the @Component (because then we can't see the all the classes which I need the beans of in one glance), in such scenario, we can create a public method inside the Configuration Class(created in Step1) which returns an object of the required class and then annotate the method with @Bean.

3. We need to create an object of ApplicationContext but instead of ClassPathXmlApplicationContext we will use AnnotationConfigApplicationContext().

4. AnnotationConfigApplicationContext(), this method except an argument which is of a class type. We need to provide the class of the configuration we created in step 1.

5. Now my main method knows which class is the configuration class which contains all the information about the pacakge of which we might need to create the bean of.

6. Once this is done we need to get the bean:
	1. We have annotated all the class for which we might need the bean in step 2
	2. Since we are not using the @Component in the process hence the name of method which returns me the respective object becomes the name of the bean.
	3. Now we will use the context.getBean("name deduced from step2",Bean'sClass.class) 
	4. This is provide me the required beans.
7. Now that we have the bean/object we can use it as per our requirements.

Note: If we are taking the alternate way we will be returning all the objects from the method inside the Configuration class. Since the class is returning all the objects, it can't be done without the class having the information about the pacakage in which the bean class is present. Hence we do not need to provide the @ComponentScan annotation in this case.

Adding dependencies:
1. Add the supporter variable inside the dependent class.
2. Annotate the variable with @Autowired
3. There are 4 possiblities below:
	
	1. If the dependent class is annotated with @Component & Supporter Class is not :
	
	2. If the dependent class is not annoatted but the supported class is annotated with @Component:

	3. If both the classes are annotated with @Component:

	4. If both the classes are not annotated with @Component:

Class Assignment: Figure out possiblilities 1 & 2



Solution:

	1. If the dependent class is annotated with @Component & Supporter Class is not : In that case we need to provide the base pacakage(dependent class) in the Configuration file. And create the getter method of supporter class inside the Cofiguration file
	
	2. If the dependent class is not annoatted but the supported class is annotated with @Component: In that case we need to provide the base pacakage(supporter class) in the Configuration file. And create the getter method of dependent class inside the Cofiguration file.

	3. If both the classes are annotated with @Component: We need to provide the base pacakages of both the classes.

	4. If both the classes are not annotated with @Component: We need to create the respective getter methods inside the configuration file.

Note: Please make sure that we are using the correct bean name in context.getBean("") as per the respective situation


Note: While declaring the @Bean, we can also provide single/multiple names and it will save the returning bean in any & all of these names.

Annotation so far:
@Component
@Value
@ComponentScan
@Configuration
@Autowired
@Bean
@Qualifier