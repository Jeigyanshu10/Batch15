Collection Framework and its charaterstics:



Below are some import classes/interfaces and its charterstics:

1. Collection: 
	1.When we want to represent a group of individual obejects as a single entity, then we should use collection.
	2. Collection interface defines most common methods which are applicable for any collection objects.
	3. We use Collection interface to hold and transfer objects from one place to another. Hence the Collection interface implements Serializable and clonable interface.

2. List:(interface) 
	1. Introduced in 1.2 Version of Java 
	2. Allows duplicate
	3. User have control over the insertion order. i.e. intertion order is maintained.
	4. It allows null as an object.

3. ArrayList:(class implements List)
	1. ArrayList allows duplicates.
	2. ArrayList maintains intersertion order.
	3. Provides implementation to the List interface.
	4. Provides methods to add, get or manipulate the elements in the ArrayList.
	5. ArrayList is non-synchronized.
	6. There are 3 constructors:
		a. ArrayList()
		b. ArrayList(int initial capacity)
		c. ArrayList(Collection c) 
	7. Underlying data structure is resizable-array(dynamic array) of Object class, hence it works at the index basis.
	8. The formula in which the ArrayList grow: 
		new capacity = (currentCapacity*3/2)+1
	9. Apart from the Serilizable and clonable interface, the ArrayList also implements RandomAccess interface which allow the serach operation really fast.
	10. Best choice is when we have to perform retrival operations. Worst Choice: Ifn we have to insert or remove/delete in middle of the ArrayList.		
	11. How to get synchronized version of ArrayList:
		ArrayList al = new ArrayList();
		List l = Collections.syncronizedList(al);	

3. LinkedList: (Class implements List & Deque):
	1. Allows to contain duplicate elements.
	2. LinkedList maintains intertion order.
	3. Provides implementation to the List interface.
	4. Provides methods to add, delete, get & manipulate the contents of the LinkedList.
	5. LinkedList is non-synchronized.
	6. LinkedList has 2 constructors, they are:
		a. LinkedList()
		b. LinkedList(Collection c)
	7. The underlying data structure is doubly linked-list. Because of the this the manipulation is fast because there is no shifting needs to occurs.
	8. The elements are not going to be stored in consecutive memory location.
	9. Every element we add to the LinkedList will create a seprate node which will have 3 blocks inside it. Below are the arrangement of the object and references:
		a.The object itself will be stored in the middle.
		b.The first block of the mode will contain the address of the previous node.
		c.The last block will contain the address of the next node.
	10. Because of the above arrangement, the insertion and the deletion becomes very easy and fast as well.
	11. Worst choice: Retrival of the objects from the LinkedList.
	12. There are 6 unique methods of LinkedList to provide support for Stack and Queue:
		a. void addFirst(Object o)
		b. void addLast(Object o)
		c. Object getFirst()
		d. Object getLast()
		e. Object removeFirst();
		f. Object removeLast();	  

Difference Between ArrayList and LinkedList:

		ArrayList                               |                         LinkedList
	1. Best choice: When frequent operation is  |1. Best choice: When frequent operation is insertion
	    retrival.									in middle.
	2. Worst choice: When frequent operation is |2. Worst Choice: When frequent operation is     
		insertion in middle							retrival.
	3. Underlying DS: Resizable/growable array  |3. Underlying DS: Doubly Linked-List	
	4. Implements RandomAccess interface 		|4. Doesn't Implements RandomAccess interface


4. Vector:
	1. Allows to contain duplicate elements.
	2. Vector maintains intertion order.
	3. Provides implementation to the List interface.
	4. Provides methods to add, delete, get & manipulate the contents of the vector.
	5. LinkedList is synchronized.
	6. Vector has 4 constructors:
		a. Vector()
		b. Vector(int initialCapacity)
		c. Vector(int initialCapacity, int capacityIncrement)
	7. Underlying data structure is resizable-array(dynamic array) of Object class, hence it works at the index basis.
	8. Apart from the Serilizable and clonable interface, the Vector also implements RandomAccess interface which allow the serach operation really fast.
	9. Default initial capacity 10. But the growth mechanism is calculated by the formula
		new capacity = currentCapacity*2


Difference Between ArrayList & Vector:

		ArrayList                               |                         Vector
	1. Not-Synchronized							|1. Syncronized									
	2. Not Thread-safe							|2. Thread safe     
	3. High performance							|3. Low Performance
	4. new capacity is calculated by the formula|4. new capacity is calculated by the formula 
		nc=(cc*3/2)+1   							nc = cc*2


5. Stack:
	1. The stack is based on liner data structure.
	2. It is based on Last-in-first-out(LIFO).
	3. It defines a lot of methods which helps us to carry out different operations like push,pop,search, etc..
	4. Only contain default constructor. i.e:
		public Stack();	


Cursors:
	1. If we want to retrive/get/fetch objects from the Collection one after another, then we need to go for cursor.
	2. There are 3 types of cursors in Java:
		a. Enumeration
		b. Iterator
		c. ListIteretor


a. Enumeration:
	1. To make use of the enumeration,first we need to get the enumeration object.
	2. We can get enumeration object by calling the elements method in the vector class
	3. Syntax: Enumeration e = v.elements();//Where v is any vector object.
	4. There are 2 methods in Enumeration interface.
		1. hasMoreElement();//type boolean and provide output true or false if there are more objects in the Collection.
		2. nextElement();//Returns the next elements(object).
	5. disadvantage: 
		1. Only applicable for legecy classes.
		2. We can only perform read operation. If an object is no longer required we can't perform remove operation.	

b. Iterator:
	1. This universal cursor, which mean it is applicable for any Collection interface class.
	2. We can perform read and remove operation using Iterator.
	3. Present in the Collection interface which gives us Iterator object.
	4. Signature of Iterator: public Iterator iterator()
		eg: Iterator itr = c.iterator();//Here c is any collection object.
	5. Methods:
		1. public boolean hasNext();
		2. public Object next();
		3. public void remove();	
	6. Limitations: 
		1. It only moves in forward direction. 
		2. It can read, remove but replace or addition of new object functionality is unavailable.
c. ListIterator:
	1. ListIterator is bi-direction cursor.
	2. Using ListIterator we can perform replacement & addition of new object with addition to read & remove objects from the Collection.
	3. Signature: public ListIterator listIterator()// Present in the List interface.
		eg: 	ListIterator ltr= l.listIterator()// Here l is any List object.
	4. Methods:	
		1. public boolean hasNext();
		2. public Object next()
		3. public int nextIndex()
		4. public boolean hasPrevious()
		5. public Object previous()
		6. public int previousIndex()
		7. public void remove()
		8. public void set(Object new)
		9. public void add(Object new)
	5. Limitation: Only applicable for List objects.	

6. Set:
	1. Introduced in 1.2 version of java
	2. It cannot contain duplicates
	3. Its an unorded collection because it doesn't maintain any insertion order. However there are expection to this(LinkedHashSet).
	4. It implements the mathematical set. Hence if we need any sort of matematical oprations, set is our friend.

7. HashSet:
	1. It implements the Set interface.
	2. It stores the elements by a mechanism called hashing.
	3. It can only contain unique elements, which means there cannot be any duplicates.
	4. HashSet doesn't maintain intertion order. The elements are stored on the the basis of their hashcode.
	5. HashSet is non-synchronized.
	6. The best use case for HashSet is where we need some sort of search operation.
	7. Initial capacity of the HashSet is 16.
	8. Constructors of HashSet:
		a. HashSet()
		b. HashSet(int initialCapacity)
		c. HashSet(int initialCapacity, float loadFactor)
		d. HashSet(Collection c)

8. LinkedHashSet:
	1. Provides implementation to Set interface.
	2. Just like the HashSet it can only contain unqiue elements.
	3. LinkedHashSet is non-Synchronized.
	4. LinkedHashSet unlike other Set classes/interfaces, maintains insertion order.
	5. Constructors of LinkedHashSet:
		a. LinkedHashSet()
		b. LinkedHashSet(Collection c)
		c. LinkedHashSet(int capacity)
		d. LinkedHashSet(int capacity,float fillRatio)

9. SortedSet:
	1. It is an interface.
	2. Duplicates are not allowed in SortedSet.
	3. It also provides a particular ordering on its elements. The elements are ordered either by using natural ordering(Ascending order) or by using a Comparator.

10. NavigableSet:
	1. Extends/Inherit from SortedSet.
	2. In addition to the sorting that happens in the SortedSet, the navigableSet provides methods to navigte through the elements in the NavigableSet.

11. TreeSet:
	1. This is a class which implements NavigableSet. It also inherits AbstractSet.
	2. Stores the elements in ascending order even when explicit comparator is not provided.
	3. Doesn't allow null elements.
	4. TreeSet is non-synchronized.
	5. Constructors of TreeSet:
		1. TreeSet()
		2. TreeSet(Collection c)
		3. TreeSet(Comparator e comparator)
		4. TreeSet(SortedSet<E> s)

12. Queue:
	1. Queue is an interface that extends the Collection interface.
	2. The main usage of the Queue is, it orders the elements in First-in-First-out manner(FIFO).
	3. If we want to represent a group of individual objects prior to processing, then we should go for Queue.

13. Priority Queue:
	1. The priority queue does not follow the fifo structure, rather it is designed to process the objects based on its priority.
	2. In order for the priority to work on a given attribute of an object, this object has to implement the Comparator interface.

14. Deque:
	1. 	This is an interface which extends Queue interface.
	2. This is related to double-ended queue that supports FIFO and LIFO.
15. ArrayDeque:
	1. This is a subclass of Deque.
	2. This is a special kind of array that grows and allows users to add or remove elements from both side of the queue.
----------------------------------------------------------------------------------------------
	
Map:
1. Map is not a child interface of Collection.
2. We should always go for Map if we want represent a group of value as key value pair.
3. Each of the key and value pair is known as an individual entry.
4. Both keys and values are objects only.
5. A map can have duplicate values but cannot have duplicate keys.
6. In case we try to provide with a duplicate key in that case it simply replace the value to the new value 
7. Map interface has its own methods. Unlike Collection methods it accepts 2 arguments for carrying out basic operation.
	eg: put(Object key, Object value)

8. Some important methods:
   1. Object  put(Object key, Object value)
	To add 1 key value pair to the map, if the key is already present then old value will be replaced with new value and the put() will return the old value. If the key is not present then it will return null.

	m.put(101,"Anshu");//null
	m.put(102,"jiggy");//null
 	m.put(101,"Jeigyanshu");// Anshu
    
    2. m.putAll(map m)//merge a smaller map to a larger map.

    3. m.get(key);//Fetch the value of a known key.

    4. m.remove(key);//Removes the entry associated with this key.

    5.m.containsKey(key);//checks if a particular key is available in the map.

    6.m.containsValue(key);//checks if a particular value is available in the map.

    7. m.isEmpty();//Check if the map is empty or not.
    8. m.size();//Returns the size of the map.
    9.  Set keySet()//returns a set of keys
    10. Collection values();returns a collection of values.
    11. Set entrySet();//Returns a set of entry objects.
Note. methods 9,10 & 11 are called as Collection views of Map.

Entry interface:
1. Entry is inner interface of Map interface.

2. Entry interface methods: 
interface Map{
	
	interface Entry{
		Object getKey();
		Object getValue();
		Object entrySet(Object newObject);
	}
}	

HashMap:
1. Underlying dataStrcture: Hashtable
2. insertion order is not preserved.
3. It is based on Hashcode of Keys.
4. Duplicate keys are not allowed, but duplicate values are allowed.
5. Hetrogeneous keys and values are allowed.
6. Null is allowed for key but only once.But we can store null for values any number of times.
7. It implements Serilizable and cloneable marker interface
8. Best Choice: Where search is the frequent operation.
9. Constructors:
  a.HashMap m = new HashMap();
 		Default initial Capacity:16,
 		Default fill ratio: 0.75
  b. HashMap m = new HashMap(int initialCapacity); //Default fill ratio: 0.75
  c.HashMap m = new HashMap(int initialCapacity,float fillRatio);
  d.HashMap m = new HashMap(Map m);	

Differences Between HashMap and Hashtable:

HashMap               |             Hashtable
1.Non-synchronzied	  |	1. Synchronized
2.Not Thread-safe     | 2. Thread-safe
3.Performance is high | 3. Low performance
4.Null is allowed for | 4. Null not allowed for
  key and value	 			either key or value
5.Non legecy(1.2 v)   | 5. Legecy class.

Synchronized Version of HashMap objects:
HashMap m = new HashMap();
Map m1 = Collections.synchronizedMap(m); 

LinkedHashMap:
1.Child class of HashMap
2.Underlying DS: combination of LinkedList & Hashtable
3.Insertion order is preserved.
4.Introduced in 1.4 version
Note:
1. Except these points, LinkedHashMap is exactly same as HashMap(including constructors and methods).
2. LinkedHashSet and LinkedHashMap are commonly used for developing cache based applications.

IdentityHashMap
Difference Between == & .equals()
1. In general == operator is meant for comparing the refernce(address). However, .equals() meant for content comparision

Integer I1 = new Integer(10);
Integer I2 = new Integer(10);
System.out.println(I1==I2);//false
System.out.println(I1.equals(I2));true

IdentityHashMap m = new IdentityHashMap();
Integer I1 = new Integer(10);
Integer I2 = new Integer(10);
m.put(I1,"Jeigyanshu");
m.put(I2,"Sarangi");
System.out.println(m);
//Here I1 and I2 are not identical keys. In case of IdentityHashMap JVM will use "==" operator to identify the keys, but incase of HashMap JVM will consider ".equals()" to identify the keys. In the above example since the I1 and I2 hashcode are different hence it will have 2 different entries.

Other than this difference, IdentityHashMap is exactly the same as HashMap(including constructor and methods).


WeakHashMap:
In case of a HashMap object, if there are no reference pointing to a key object which is associated(is one of the keys) with the HashMap, in that case the garbace collector has no capability to destroy the object. However, in case of the WeakHashMap if there are no reference pointing to a key object which is associated with the WeakHashMap then the garbage collector is capable of destroying the object which in return will remove the entry from the WeakHashMap.

- Other than this difference the WeakHashMap is exactly the same as of the HashMap(Including constructor and methods).


SortedMap:
1. Child interface of Map.
2. If we want to represent a group of key value pairs, where all the entries will be saved to the Map based on some sorting order of the Keys then we should go for SortedMap.
3. It is important to notice, sorting is based on the key but not the value.


4. methods:

Lets consider this SortedMap Object:
	101 -----> A
	103 -----> B
	104 -----> C
	107 -----> D
	125 -----> E
	136 -----> F
Based on the above SortedMap:	
	firstKey();//101
	lastKey();//136
	headMap(107);//{101=A,103=B,104=C}
	tailMap(107);//{107=D,125=E,136=F}
	subMap(103,125);//{103=B,104=C,107=D}
	comparator();//Null,since the SortedMap is already sorted.

TreeMap:
1. It provides implementation to the SortedMap.
2. Underlying DS RED-BLACK tree.
3. Insertion order is not preserved.
4. Elements will be inserted in the sorting order of keys.
5. Duplicate keys are not allowed, but duplicate values are allowed.
6. If we are depending on default natural sorting order,Keys should be homogeneous and comparable. However, If we are defining our own sorting by comparator, then the keys need not be homogeneous and comaparable.		
7. There are no restriction on the values whatsoever. 
8. Null not applicable for TreeMap. If at all we try to put null as a key then we will get NullPointerException.
9. Constructors:
	1. TreeMap tm = new TreeMap();
	inserts the elements based on default natural sorting order of keys.

	2. TreeMap tm = new TreeMap(Comparator c);
	inserts the elements based on customized sorting order of keys.	

	3. TreeMap tm = new TreeMap(Map m);
		Interconversion between Map objects.

	4. TreeMap tm = new TreeMap(SortedMap sm);		


Hashtable:
1. Underlying DS: Hashtable
2. Insertion ordered is not preserved.
3. Insertion of the elements are based on the hashcode of the keys.
4. Duplicate keys are not allowed, but values can be duplicated.
5. Hetrogeneous objects are allowed for both key and value.
6. null is not applicable for key or value.
7. Hashtable implements Serializable and Clonable but not RandomAccess.
8. Every method is synchronized hence Hashtable objects are ThreadSafe.
9. Best choice is our frequent operation is search.
10. Constructors:
	1. Hashtable ht = Hashtable()//Default initial capacity:11, Fill ratio: 0.75
	
	2. Hashtable ht = Hashtable(int initialCapacity)
	
	3. Hashtable ht = Hashtable(int initialCapacity,float fillRatio)
	
	4. Hashtable ht = Hashtable(Map m)



Properties:
1. In our program if any thing which changes frequently(like username,password,emailids,mob etc) are not recommended to hardcode in java program because if there is any change to reflect that change we will need to go through different steps like: recompilation,rebuild,redepoly application are required, even some time server restart also required which creates a big impact bussiness impact to the client.
2. To overcome this problem by using properties file. Such type of variables we have to configure in the properties file
3. From the properties file we have to read into java program and we can use those properties.
4. Main advantage of this approach is if there is a change in properties file to reflect that change we just need to redeployment is enough.
5. We can use java properties object to hold properties which are coming from properties file.
6. In normal map(like HashMap ) key and value can be anytype, but in the case of properties key and value should be of String type.
7. Constructor:
	Properties p = new Properties();
8. Methods:
	1. String getProperty(String propertyName)
	
	2. String setProperty(String pName,String pvalue)//returns old value

	3. Enumenration PropertyNames()

	4. void load(InputStream is)//loads the property from Property file into Java properties object.

	5. void store(OutputStream os, String comment)// to store properties from java properties object into properties file.

Comparable(I):
1. Present in java.lang
2. Has only one method: 
	public int compareTo(Object obj);

Eg: obj1.compareTo(obj2)
	1.Returns -ve if obj1 has to come before obj2.

	2. Returns +ve if obj1 has to come after obj2.

	3. Returns 0 if obj1 and obj2 are equal.	
3. It will give NullPointerException if we try to compare object with null.

TreeSet t = new TreeSet();
t.add("K");//Empty, there will be no comparision
t.add("Z");Z.compareTo("K")//+ve
t.add("A");A.CompareTo("K")//-ve
t.add("A");//A.compareTo("K"),//-ve A.compareTo("A")//0
System.out.println(t)//[A,K,Z]
Note: If we are not satisfied with default natural sorting order, we have to go for comparator.

Comparator:
. Comparator is an interface.
1. Present in java.util
2. Defines 2 methods:
	1.compare()
	2.equals()
- public int compare(Object obj1,Object obj2)
	1.Returns -ve if obj1 has to come before obj2.

	2. Returns +ve if obj1 has to come after obj2.

	3. Returns 0 if obj1 and obj2 are equal. 

- public boolean equals(Object obj)

3. To implement Comparator:
class myComparator implements Comparator{
	compare(){
		-
		-

	}
}
 we are should only provide implementation only for Compare(). We are not required to provide implementation for equals(), because the class providing implementation to the Comparator() already extends Object class where the euqals() is defined and it is available for the implementing class hence it is not mandatory to provide implementation to the equals().
Eg: WAP to insert integer objects into the TreeSet where the sorting order is descending order.

TreeSet t = new TreeSet();
t.add(10);
t.add(0);
t.add(15);
t.add(5);
t.add(20);
System.out.println(t);//[0,5,10,15,20]


class MyComparator implements Comparator{
	public int compare(Object obj1,Object obj1){

	Integer I1= (Interger)Obj1;
	Integer I1= (Interger)Obj1
	if(I1<I2){
		return 1;
	}else If(I1>I2){
		return -1;
	}else{
		return 0;
	} 
	}
}


TreeSet t = new TreeSet(new MyComparator());
t.add(10);
t.add(0);--->compare(0,10)//+ve
t.add(15);--->compare(15,10)//-ve
t.add(5);--->compare(5,0)//+ve,compare(5,10)//-ve
t.add(20);-->compare(20,10)//-ve,compare(20,15)//-ve,compare(20,20)//0
System.out.println(t); // 20,15,10,5,0

Note: If we are not passing the comparator object while creating the object for TreeSet then the JVM will call compareTo() of Comparable interface to give us default natural sorting order.


possible implementation of compare method:
public int compare(Object obj1,Object obj2){
	Integer I1 = (Integer)Obj1;
	Integer I1 = (Integer)Obj1;
	1.return I1.compareTo(I2);(ascending order)
	2. return -I1.compareTo(I2);(decending order)
	3. return I2.compareTo(I1);(decending order)
}



